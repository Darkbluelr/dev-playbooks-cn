# 分层约束检查清单

借鉴 VS Code 的 `code-layering.ts` 和 `layersChecker.ts`，本文档定义了分层架构的检查规则。

---

## 1) 分层依赖检查规则

### 1.1 单向依赖违规检测

**检查方式**：扫描 import/require 语句，验证依赖方向

```typescript
// 违规示例：base 层引用 platform 层
// src/base/utils.ts
import { ConfigService } from '../platform/config';  // 违规！

// 正确示例：platform 层引用 base 层
// src/platform/config.ts
import { deepClone } from '../base/utils';  // 合法
```

**检查命令示例**（使用 grep/rg）：

```bash
# 检查 base 层是否违规引用 platform
rg "from ['\"].*platform" src/base/ --type ts

# 检查 common 层是否违规引用 browser/node
rg "from ['\"].*(browser|node)" src/common/ --type ts
```

### 1.2 环境隔离违规检测

| 环境 | 禁止的 API | 检测正则 |
|------|-----------|---------|
| common | DOM API | `document\.|window\.|navigator\.` |
| common | Node API | `require\(['"]fs['"]\)|process\.|__dirname` |
| browser | Node API | `require\(['"]fs['"]\)|child_process` |
| node | DOM API | `document\.|window\.|DOM\.` |

### 1.3 contrib 反向依赖检测

```bash
# 检查 core 是否违规引用 contrib
rg "from ['\"].*contrib" src/core/ --type ts
rg "from ['\"].*contrib" src/workbench/services/ --type ts
```

---

## 2) 分层约束定义模板

在 `<truth-root>/architecture/c4.md` 中添加：

```markdown
## Architecture Guardrails

### Layering Constraints

本项目采用 N 层架构，依赖方向为：base ← platform ← domain ← application ← ui

| 层级 | 目录 | 职责 | 可依赖 | 禁止依赖 |
|------|------|------|--------|----------|
| base | src/base/ | 基础工具、跨平台抽象 | （无） | 所有其他层 |
| platform | src/platform/ | 平台服务、依赖注入 | base | domain, app, ui |
| domain | src/domain/ | 业务逻辑、领域模型 | base, platform | app, ui |
| application | src/app/ | 应用服务、用例编排 | base, platform, domain | ui |
| ui | src/ui/ | 用户界面、交互逻辑 | 所有层 | （无） |

### Environment Constraints

| 环境目录 | 可引用 | 禁止引用 |
|----------|--------|----------|
| */common/ | 平台无关库 | */browser/*, */node/* |
| */browser/ | */common/* | */node/* |
| */node/ | */common/* | */browser/* |

### Validation Commands

```bash
# 分层违规检查
npm run valid-layers-check

# 或手动检查
rg "from ['\"].*platform" src/base/ --type ts && echo "FAIL: base→platform" || echo "OK"
```
```

---

## 3) 分层违规的严重程度

| 违规类型 | 严重程度 | 处理方式 |
|----------|----------|----------|
| 下层引用上层 | **Critical** | 必须立即修复，阻止合并 |
| common 引用 browser/node | **Critical** | 必须立即修复 |
| 跨层深度导入 Internal 模块 | **High** | 应使用公共 API |
| contrib 被 core 引用 | **High** | 违反扩展点设计 |
| 循环依赖 | **High** | 需要重构解耦 |

---

## 4) 分层检查集成

### 4.1 在 ESLint 中配置（推荐）

```javascript
// eslint.config.js
module.exports = {
  rules: {
    'import/no-restricted-paths': ['error', {
      zones: [
        // base 禁止引用 platform
        { target: './src/base', from: './src/platform', message: 'base cannot import platform' },
        // platform 禁止引用 domain
        { target: './src/platform', from: './src/domain', message: 'platform cannot import domain' },
        // common 禁止引用 browser/node
        { target: './src/**/common', from: './src/**/browser', message: 'common cannot import browser' },
        { target: './src/**/common', from: './src/**/node', message: 'common cannot import node' },
      ]
    }]
  }
};
```

### 4.2 在 TypeScript 中配置

为每个层创建独立的 tsconfig：

```json
// tsconfig.base.json
{
  "compilerOptions": {
    "paths": {
      // base 层只能看到自己
    }
  },
  "include": ["src/base/**/*"],
  "exclude": ["src/platform/**/*", "src/domain/**/*"]
}
```

### 4.3 在 CI 中配置

```yaml
# .github/workflows/pr.yml
- name: Check layer constraints
  run: |
    # 检查分层违规
    ./scripts/valid-layers-check.sh || exit 1
```

---

## 5) 分层重构指南

当发现分层违规时：

1. **识别违规原因**
   - 是否是合理的依赖？（可能需要调整分层定义）
   - 是否可以通过接口抽象解耦？
   - 是否应该将代码移动到正确的层？

2. **解耦策略**
   - **依赖注入**：上层通过接口注入，下层不直接依赖实现
   - **事件机制**：下层发布事件，上层订阅
   - **回调传递**：下层接收回调函数，不关心调用者

3. **代码移动**
   - 如果代码确实属于下层，移动到正确位置
   - 更新所有引用路径
   - 运行分层检查确认修复

---

## 6) 审查检查项

在 Code Review 时，检查以下项目：

- [ ] 新增的 import 是否遵守分层约束？
- [ ] 是否引入了 Internal 模块的深度导入？
- [ ] common 目录下的代码是否使用了平台特定 API？
- [ ] contrib 模块是否被 core 模块引用？
- [ ] 是否存在循环依赖？
