# 编排逻辑伪代码

## 主编排函数

```python
def run_delivery_workflow(user_requirement):
    """
    主 Agent 只执行此编排逻辑，不做任何实际工作。
    Delivery 是唯一入口：以 request_kind 驱动最小充分闭环（不是固定阶段表）。
    """

    # 0) 配置发现（优先 .devbooks/config.yaml），加载 agents_doc + constitution
    config = discover_config()

    # 1) 确保变更包存在（脚手架：proposal/RUNBOOK/inputs/evidence 目录等）
    change_id = ensure_scaffold(config, user_requirement)
    verify_output(f"{change_root}/{change_id}/proposal.md")

    # 2) 路由：判定 request_kind + 最短闭环 + 升级条件（必要时追问用户并冻结）
    route = derive_route(change_id=change_id, user_requirement=user_requirement)
    # route.request_kind: debug|change|epic|void|bootstrap|governance
    # route.steps: ordered list of stage objects (skill + constraints + required_artifacts)

    if route.request_kind == "void":
        # 只做澄清/Freeze/Thaw，结束后再回到 Delivery 重新路由
        call_subagent("devbooks-void", {"change_id": change_id, "task": "澄清关键问题并输出可执行下一步"})
        return "void: need-more-context"

    # 3) 执行：只跑本次最小充分闭环（但任何触发升级条件的环节都必须补齐）
    for step in route.steps:
        result = call_subagent(step.skill, step.payload)
        if result.status in ("REJECTED", "REVISE", "REVISE REQUIRED"):
            return handle_revision(step, result)
        verify_artifacts(step.required_artifacts)

    # 4) 归档：只有当 route 要求进入归档（或用户明确要求闭环结束）才执行
    # Archiver 会自动运行 change-check.sh --mode strict
    if route.should_archive:
        call_subagent("devbooks-archiver", {"change_id": change_id, "task": "执行归档"})
        return "archived"

    return "paused: awaiting next instruction"
```
