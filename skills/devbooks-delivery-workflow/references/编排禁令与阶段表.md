# 编排禁令与阶段表

## 🚨 绝对禁令（ABSOLUTE RULES）

> 这些规则没有例外，违反即失败。

### 禁令 1：禁止主 Agent 直接工作

```
❌ 禁止：主 Agent 自己写 proposal.md / design.md / tests/ / src/
❌ 禁止：主 Agent 直接修改任何变更包内容
❌ 禁止：主 Agent 跳过子 Agent 调用

✅ 必须：所有工作通过 Task 工具调用子 Agent 完成
✅ 必须：每个阶段都有对应的子 Agent 调用
✅ 必须：主 Agent 只做编排、等待、验证
```

### 禁令 2：禁止跳过任何强制阶段

```
❌ 禁止：把“固定阶段表”当作流程本体
❌ 禁止：在 `request_kind` 明确后仍盲目跑全套流程（制造无意义成本）
❌ 禁止：跳过**当前闭环所需**的强制闸门/证据（例如需要 Knife/追溯/评审却省略）

✅ 必须：以 `request_kind` 为主轴，选择**最小充分闭环**
✅ 必须：当触发升级条件（高风险/史诗/治理/外部契约/跨模块）时，自动补齐对应环节
✅ 必须：任何归档都要先通过与本次变更匹配的闸门检查（`change-check.sh --mode strict` 由 Archiver 执行）
```

### 禁令 3：禁止假完成归档

```
❌ 禁止：evidence/green-final/ 不存在或为空时归档
❌ 禁止：verification.md AC 覆盖率 < 100% 时归档
❌ 禁止：tasks.md 存在未完成任务时归档
❌ 禁止：change-check.sh --mode strict 失败时归档

✅ 必须：Archiver 子 Agent 先运行检查脚本
✅ 必须：所有检查通过后才执行归档
```

### 禁令 4：禁止演示模式（NO DEMO MODE）

```
❌ 禁止：将工作流当作"演示"或"展示"
❌ 禁止：输出"演示已完成"、"工作流演示"等措辞
❌ 禁止：声称完成但实际产物不存在或为空
❌ 禁止：用"模拟"、"假设"、"如果"代替实际执行

✅ 必须：每个阶段都要产出真实的、可验证的产物
✅ 必须：产物必须写入文件系统（可通过 ls/cat 验证）
✅ 必须：使用"执行"、"完成"、"已创建"等真实动作词汇
✅ 必须：如果无法真实执行，立即停止并告知用户
```

检测演示模式的信号：
- 使用"演示"、"展示"、"模拟"等词汇
- 声称完成但没有实际文件写入
- 提供"选项 A/B"而非执行下一步
- 输出"后续建议"而非继续执行

### 禁令 5：禁止忽略 REVISE REQUIRED

```
❌ 禁止：收到 REVISE REQUIRED 后继续下一阶段
❌ 禁止：收到 REVISE REQUIRED 后声称"已完成"
❌ 禁止：收到 REVISE REQUIRED 后提供"选项"让用户选择
❌ 禁止：收到 REJECTED 后继续执行

✅ 必须：Judge 返回 REVISE → 回到 Proposal Author 重写提案
✅ 必须：Judge 返回 REJECTED → 停止流程，告知用户
✅ 必须：Test-Review 返回 REVISE REQUIRED → 回到 Test Owner 修复测试
✅ 必须：Code-Review 返回 REVISE REQUIRED → 回到 Coder 修复代码
✅ 必须：修复后重新执行评审阶段，直到通过
```

### 禁令 6：禁止部分完成前进

```
❌ 禁止：tasks.md 任务完成率 < 100% 时进入下一阶段
❌ 禁止：测试覆盖率 < AC 要求时进入下一阶段
❌ 禁止：存在空壳测试（skip/todo/not_implemented）时进入 Code 阶段
❌ 禁止：存在未实现函数（raise NotImplementedError）时进入 Review 阶段

✅ 必须：Test Owner 阶段完成时，所有测试必须是真实的、可执行的
✅ 必须：Coder 阶段完成时，tasks.md 所有任务 100% 完成
✅ 必须：如果发现范围过大，必须拆分变更包，不能部分完成
```

---

## P3-3 行动规范（主代理执行约束）

> 这些约束用于对抗“长流程遗忘/口径漂移/产物不落盘/多变更串线”等高频事故。  
> 原则：**把记忆变成闸门，把口头变成工件。**

### 1) 先选一位“人类大师视角”，主代理只编排不下场

- 主代理必须在任务开头显式选择一位真实存在的人类大师视角（用于全局掌控与长期一致性），例如：Fred Brooks / Martin Fowler / Richard Feynman（按任务性质选其一）。  
- 主代理只做：编排、等待、验证、裁决；不得执行 Proposal/Test/Code/Review 等节点工作。

### 2) 子代理模型建议（when available）

- `coder` 与 `test-owner`：优先使用更偏编码/工具执行的模型（示例：`gpt-5.2-codex xhigh`）。  
- 其他角色（proposal/design/reviewer 等）：使用通用推理模型（示例：`gpt-5.2 xhigh`）。  
- 模型名称仅作示例；若平台不可指定模型，则以角色隔离与闸门证据为准。

### 3) 子代理产物落盘规则（同文件合并，不同文件编号）

- 若多个子代理共同修改同一文件：合并后直接落盘到该文件（避免散落在聊天里不可复验）。  
- 若产物是独立文档（challenge/review/judge/archiver report）：必须写入变更包，并以序号区分多次输出：
  - `challenge-1.md`、`proposal-judge-1.md`、`test-review-1.md`、`code-review-1.md`、`archiver-report-1.md` …

### 4) 多个 change 并行：必须持续声明当前 change 包

- 每个阶段开始前都要声明：当前 `change-id` 与变更包路径。  
- 若从零开始：由 Delivery 入口创建变更包骨架（`change-scaffold.sh` 或等价方式）。  
- 若断点续跑：先检查已有产物（proposal/design/tasks/verification/evidence），再从最近完成阶段继续。

### 5) 结束条件：跑完 Archiver 才算结束

- 不得以“已绿/已通过测试”作为结束；必须跑完归档阶段并形成可审计的归档产物。  
- 中途不得停下来询问“是否继续”；以既定规则与闸门推进到归档闭环完成。

### 6) Codex CLI 多代理节奏：等待子代理完成后再推进

- 在支持子代理的工具中：调用子代理后，应等待其完整产出落盘，再进入下一阶段（避免频繁打断导致产物缺失/漂移）。  
- 平台不支持子代理时：按框架“降级策略”执行（由人类分开两个独立会话分别跑 Test Owner 与 Coder，主代理只给步骤与校验）。

## 前置：配置发现

执行前必须按以下顺序查找配置：
1. `.devbooks/config.yaml`（如存在）→ 解析并使用其中的映射
2. `dev-playbooks/project.md`（如存在）→ Dev-Playbooks 协议
3. `project.md`（如存在）→ template 协议
4. 若仍无法确定 → 停止并询问用户

SSOT 基线（MUST）：
- 若缺少项目级 SSOT（`<truth-root>/ssot/SSOT.md` 与 `<truth-root>/ssot/requirements.index.yaml`），必须先路由到 `request_kind=bootstrap` 补齐（可用 `ssot-scaffold.sh` 生成最小骨架；进度视图可用 `requirements-ledger-derive.sh` 派生，属于可丢弃缓存）。

---

## 路由表（按 `request_kind` 的最小充分闭环）

> `request_kind` 是入口分流主轴：**debug | change | epic | void | bootstrap | governance**。  
> Delivery 的职责是：在成本与确定性之间做最小充分选择，并在触发升级条件时自动补齐环节。

### A) 最短闭环（MUST）

| request_kind | 最短闭环（仅列必须节点） |
|---|---|
| debug | Impact（可选但推荐）→ Test Owner（最小复现/Red）→ Coder（Green）→ Review → Green Verify → Archive |
| change | Proposal（Author/Challenge/Judge）→ Design → Spec（按需）→ Plan → Test Owner → Coder → Review → Green Verify → Archive |
| epic | Knife（Plan）→ Proposal（Author/Challenge/Judge）→ Design → Spec → Plan → Test Owner → Coder → Review → Green Verify → Archive |
| governance | Proposal（Author/Challenge/Judge）→ SSOT Maintainer（当涉及 SSOT/index/ledger）→ docs-consistency（按需）→ Review → Archive |
| bootstrap | brownfield-bootstrap →（必要时）Proposal/Design/Spec/Plan → Archive |
| void | Void（澄清问题/Freeze/Thaw）→ 路由到 bootstrap / knife / change / debug |

### B) 升级条件（WHEN）

- **高风险**：`risk_level=high` → Knife Plan / 验证锚点 / 史诗对齐等闸门会升级为强制项
- **史诗/治理**：`request_kind=epic|governance` → 需要更强的证据与交接（Context Capsule、scope evidence bundle 等）
- **对外契约变化**：出现 schema/API/event 等外部契约变更 → 强制补 Spec Contract + contract tests + 向后兼容策略
- **跨模块/架构边界**：触发 Impact Analysis → 在 Proposal 前或 Proposal 后补齐影响分析并回写
- **文档/模板交付物**：deliverables 涉及 `README/docs/templates` → 强制 docs-consistency 证据

---

## 上下文感知

### 检测流程

1. 检测变更包是否存在
2. 检测当前阶段（哪些阶段已完成）
3. 从断点继续执行

### 断点续跑

若变更包已存在部分产物，从最近完成的阶段继续：

```
检测结果：
- 变更包：存在
- 已完成产物：proposal/design/spec/tasks
- 下一步建议：Test Owner（建立 Red 基线 / verification.md）
- 运行模式：断点续跑
```

---

## 可选检查脚本

脚本位于本 Skill 的 `scripts/` 目录：

- 初始化项目级 SSOT：`ssot-scaffold.sh`
- 派生需求进度账本（可丢弃缓存）：`requirements-ledger-derive.sh`
- SSOT 维护与索引同步：见 `skills/devbooks-ssot-maintainer/`（delta → index sync → 可选 ledger refresh）
- 初始化变更包骨架：`change-scaffold.sh`
- 一键校验变更包：`change-check.sh`
- 结构守门决策校验：`guardrail-check.sh`
- 证据采集：`change-evidence.sh`
- 进度仪表板：`progress-dashboard.sh`
