# 解依赖技术速查表（8 种高频技术）

> 来源：《修改代码的艺术》第 25 章（从 24 种精选）
> 适用角色：Test Owner / Coder

---

## 速查索引

| # | 技术 | 一句话描述 | 频率 | 适用场景 |
|---|------|----------|------|---------|
| 1 | Extract Interface | 提取接口隔离外部依赖 | ⭐⭐⭐ | 外部服务/数据库/第三方 API |
| 2 | Parameterize Constructor | 通过构造器注入依赖 | ⭐⭐⭐ | 硬编码依赖、new 操作在构造器 |
| 3 | Subclass and Override | 子类化并覆写方法 | ⭐⭐⭐ | 需要替换部分行为、无法修改原类 |
| 4 | Introduce Static Setter | 为静态依赖提供 setter | ⭐⭐ | 单例、全局对象、静态工厂 |
| 5 | Extract and Override Getter | 提取 getter 并覆写 | ⭐⭐ | 字段依赖、延迟初始化 |
| 6 | Break Out Method Object | 将方法提取为对象 | ⭐⭐ | 过长方法、复杂算法 |
| 7 | Adapt Parameter | 为参数创建适配器 | ⭐ | 难以 mock 的参数类型 |
| 8 | Encapsulate Global References | 封装全局变量 | ⭐ | 全局状态、环境变量 |

---

## 1. Extract Interface（提取接口）

### 问题场景
```python
class OrderService:
    def __init__(self):
        self._payment = PaymentGateway()  # 硬编码依赖真实支付网关
        self._inventory = InventoryDB()    # 硬编码依赖真实数据库

    def process(self, order):
        self._payment.charge(order.total)  # 无法测试：会真实扣款
        self._inventory.deduct(order.items)
```

### 解决方案
```python
# 1. 提取接口
class PaymentGatewayInterface(Protocol):
    def charge(self, amount: Decimal) -> bool: ...

class InventoryInterface(Protocol):
    def deduct(self, items: list[Item]) -> None: ...

# 2. 原类实现接口（可选）
class PaymentGateway(PaymentGatewayInterface):
    def charge(self, amount): ...

# 3. 通过构造器注入
class OrderService:
    def __init__(self, payment: PaymentGatewayInterface, inventory: InventoryInterface):
        self._payment = payment
        self._inventory = inventory

# 4. 测试时注入 Mock
def test_order_service():
    mock_payment = Mock(spec=PaymentGatewayInterface)
    mock_inventory = Mock(spec=InventoryInterface)
    service = OrderService(mock_payment, mock_inventory)
    service.process(order)
    mock_payment.charge.assert_called_once_with(order.total)
```

### 要点
- 接口定义"契约"，实现可替换
- 测试时用 Mock 实现接口
- 生产时用真实实现

---

## 2. Parameterize Constructor（参数化构造器）

### 问题场景
```python
class ReportGenerator:
    def __init__(self):
        self._db = DatabaseConnection()  # 构造器中 new 依赖
        self._logger = FileLogger("/var/log/app.log")
```

### 解决方案
```python
class ReportGenerator:
    def __init__(self, db=None, logger=None):
        self._db = db or DatabaseConnection()  # 默认值保持向后兼容
        self._logger = logger or FileLogger("/var/log/app.log")

# 测试时
def test_report_generator():
    mock_db = Mock()
    mock_logger = Mock()
    generator = ReportGenerator(db=mock_db, logger=mock_logger)
```

### 要点
- 保留默认值，不破坏现有调用方
- 生产代码无需修改
- 测试代码可注入 Mock

---

## 3. Subclass and Override（子类化并覆写）

### 问题场景
```python
class PaymentProcessor:
    def process(self, payment):
        gateway = self._get_gateway()  # 受保护方法获取真实网关
        return gateway.charge(payment)

    def _get_gateway(self):
        return RealPaymentGateway()  # 无法在测试中替换
```

### 解决方案
```python
# 测试时创建子类
class TestablePaymentProcessor(PaymentProcessor):
    def __init__(self, mock_gateway):
        self._mock_gateway = mock_gateway

    def _get_gateway(self):  # 覆写受保护方法
        return self._mock_gateway

# 测试
def test_payment_processor():
    mock_gateway = Mock()
    processor = TestablePaymentProcessor(mock_gateway)
    processor.process(payment)
    mock_gateway.charge.assert_called_once()
```

### 要点
- 不修改原类，只在测试中扩展
- 适用于无法修改源码的情况
- 覆写的方法应尽量小

---

## 4. Introduce Static Setter（引入静态 Setter）

### 问题场景
```python
class ConfigManager:
    _instance = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls._create_real_config()  # 单例，无法替换
        return cls._instance

class MyService:
    def do_work(self):
        config = ConfigManager.get_instance()  # 依赖单例
        return config.get("api_key")
```

### 解决方案
```python
class ConfigManager:
    _instance = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls._create_real_config()
        return cls._instance

    @classmethod
    def set_instance_for_testing(cls, instance):  # 新增测试用 setter
        cls._instance = instance

    @classmethod
    def reset_instance(cls):  # 测试清理
        cls._instance = None

# 测试
def test_my_service():
    mock_config = Mock()
    mock_config.get.return_value = "test_api_key"
    ConfigManager.set_instance_for_testing(mock_config)
    try:
        service = MyService()
        result = service.do_work()
        assert result == "test_api_key"
    finally:
        ConfigManager.reset_instance()  # 清理
```

### 要点
- 仅用于测试，生产代码不应调用 setter
- 必须在 teardown 中重置
- 考虑使用 pytest fixture 自动清理

---

## 5. Extract and Override Getter（提取并覆写 Getter）

### 问题场景
```python
class OrderValidator:
    def validate(self, order):
        current_time = datetime.now()  # 直接调用，无法控制时间
        if order.expires_at < current_time:
            raise OrderExpiredError()
```

### 解决方案
```python
class OrderValidator:
    def validate(self, order):
        current_time = self._get_current_time()  # 提取为方法
        if order.expires_at < current_time:
            raise OrderExpiredError()

    def _get_current_time(self):  # 可被覆写
        return datetime.now()

# 测试
class TestableOrderValidator(OrderValidator):
    def __init__(self, fixed_time):
        self._fixed_time = fixed_time

    def _get_current_time(self):
        return self._fixed_time

def test_order_expired():
    validator = TestableOrderValidator(datetime(2024, 1, 15))
    expired_order = Order(expires_at=datetime(2024, 1, 10))
    with pytest.raises(OrderExpiredError):
        validator.validate(expired_order)
```

### 要点
- 将不可控的依赖（时间、随机数、环境）提取为方法
- 测试时通过子类覆写控制返回值
- 保持原有行为不变

---

## 6. Break Out Method Object（方法对象化）

### 问题场景
```python
class ReportEngine:
    def generate_complex_report(self, data, config, filters, formatters):
        # 200 行复杂逻辑，使用大量局部变量
        temp1 = ...
        temp2 = ...
        # 难以测试：方法太长，依赖太多
```

### 解决方案
```python
# 将方法提取为独立类
class ComplexReportGenerator:
    def __init__(self, data, config, filters, formatters):
        self._data = data
        self._config = config
        self._filters = filters
        self._formatters = formatters
        # 原来的局部变量变成实例变量
        self._temp1 = None
        self._temp2 = None

    def generate(self):
        self._step1()
        self._step2()
        return self._finalize()

    def _step1(self):  # 可单独测试
        self._temp1 = ...

    def _step2(self):  # 可单独测试
        self._temp2 = ...

# 原类委托给新类
class ReportEngine:
    def generate_complex_report(self, data, config, filters, formatters):
        generator = ComplexReportGenerator(data, config, filters, formatters)
        return generator.generate()
```

### 要点
- 长方法拆分为多个可测试的小方法
- 局部变量变为实例变量，可在测试中检查中间状态
- 原类保持接口不变

---

## 7. Adapt Parameter（参数适配器）

### 问题场景
```python
class DataProcessor:
    def process(self, http_request: HttpRequest):  # HttpRequest 难以 mock
        data = http_request.get_json()
        headers = http_request.headers
        # ...
```

### 解决方案
```python
# 创建适配器接口
class RequestData(Protocol):
    def get_json(self) -> dict: ...
    def get_headers(self) -> dict: ...

# 适配器包装真实对象
class HttpRequestAdapter:
    def __init__(self, request: HttpRequest):
        self._request = request

    def get_json(self):
        return self._request.get_json()

    def get_headers(self):
        return dict(self._request.headers)

# 修改方法签名
class DataProcessor:
    def process(self, request: RequestData):  # 依赖接口而非具体类
        data = request.get_json()
        headers = request.get_headers()

# 测试时
def test_data_processor():
    mock_request = Mock(spec=RequestData)
    mock_request.get_json.return_value = {"key": "value"}
    mock_request.get_headers.return_value = {"Content-Type": "application/json"}
    processor = DataProcessor()
    processor.process(mock_request)
```

### 要点
- 为难以 mock 的参数创建简化接口
- 生产代码使用适配器包装真实对象
- 测试代码直接 mock 接口

---

## 8. Encapsulate Global References（封装全局引用）

### 问题场景
```python
# 全局变量
DATABASE_URL = os.environ.get("DATABASE_URL")
API_KEY = os.environ.get("API_KEY")

class MyService:
    def connect(self):
        return Database(DATABASE_URL)  # 依赖全局变量
```

### 解决方案
```python
# 封装为配置类
class AppConfig:
    def __init__(self):
        self._db_url = os.environ.get("DATABASE_URL")
        self._api_key = os.environ.get("API_KEY")

    @property
    def database_url(self):
        return self._db_url

    @property
    def api_key(self):
        return self._api_key

# 注入配置
class MyService:
    def __init__(self, config: AppConfig):
        self._config = config

    def connect(self):
        return Database(self._config.database_url)

# 测试
def test_my_service():
    mock_config = Mock(spec=AppConfig)
    mock_config.database_url = "sqlite:///:memory:"
    service = MyService(mock_config)
```

### 要点
- 全局变量封装为可注入的配置对象
- 测试时可控制配置值
- 消除对环境的隐式依赖

---

## 决策流程图

```
代码无法测试？
      │
      ▼
┌─────────────────────────────┐
│ 依赖是什么类型？              │
└──────────┬──────────────────┘
     ┌─────┼─────┬─────┬──────┐
     ▼     ▼     ▼     ▼      ▼
  外部    构造器   单例   字段   全局
  服务    中new   静态   依赖   变量
     │     │     │     │      │
     ▼     ▼     ▼     ▼      ▼
 Extract  Para-  Static Extract Encap-
 Inter-   meter- Setter Override sulate
 face     ize            Getter Global
          Constr-
          uctor
```

---

## 与其他文档的关系

| 场景 | 参考文档 |
|------|---------|
| 需要在遗留代码中安全添加功能 | `低风险改动技术.md` |
| 需要找到最优测试点 | `测试驱动.md` § 7.2 Pinch Point |
| 需要评估改动影响 | `6 影响分析提示词.md` |

---

## 参考资料

- 《修改代码的艺术》第 25 章 - 解依赖技术
- dev-playbooks `devbooks-test-owner/SKILL.md`
