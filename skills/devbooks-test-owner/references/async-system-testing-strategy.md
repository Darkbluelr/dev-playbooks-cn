# Async System Testing Strategy

> Applicable scenario: Use this checklist to design testing strategies when testing systems involving message queues, event-driven architecture, eventual consistency, or distributed transactions.
>
> This document is **optional reference**, use only when the project involves async/event-driven architecture.

---

## 1) Testing Challenges of Async Systems

### 1.1 Core Difficulties

| Challenge | Description | Testing Strategy |
|-----------|-------------|------------------|
| Non-deterministic timing | Message arrival order uncertain | Use explicit wait + timeout, avoid sleep |
| Eventual consistency | System state needs time to converge | Polling verification + explicit convergence conditions |
| Idempotency verification | Duplicate messages should not cause duplicate side effects | Send same message multiple times, verify consistent results |
| Fault injection difficulty | Network partition, message loss hard to simulate | Use controllable test doubles |
| Scattered state | State distributed across multiple services/stores | Define clear "system state snapshot" method |

### 1.2 Test Pyramid Adjustment

Test pyramid for async systems differs from sync systems:

```
        /\
       /  \  E2E (minimize, only verify critical paths)
      /----\
     /      \  Contract Tests (focus: message contracts)
    /--------\
   /          \  Integration Tests (focus: message processing logic)
  /------------\
 /              \  Unit Tests (pure logic, no IO)
/----------------\
```

**Key Differences**:
- Contract Tests more important: verify message format, event envelope, schema compatibility
- Integration Tests need to cover: timeout, retry, idempotency, out-of-order processing
- E2E Tests require caution: Async system E2E easily produces Flaky Tests

---

## 2) Eventual Consistency Testing

### 2.1 Test Pattern: Polling

```python
# Recommended pattern: explicit polling + timeout
def wait_for_eventual_consistency(
    condition_fn,      # Returns True when state converged
    timeout_ms=5000,   # Maximum wait time
    poll_interval_ms=100  # Polling interval
):
    start = time.now()
    while time.now() - start < timeout_ms:
        if condition_fn():
            return True
        sleep(poll_interval_ms)
    return False

# Example: Wait for order status to sync to query service
assert wait_for_eventual_consistency(
    lambda: query_service.get_order(order_id).status == "PAID",
    timeout_ms=3000
)
```

### 2.2 Test Checklist

- [ ] Define explicit "state converged" condition (not "wait N seconds")
- [ ] Set reasonable timeout (not too short causing Flaky, not too long slowing tests)
- [ ] Test covers "convergence failure" scenario (what happens after timeout?)
- [ ] Verify if intermediate states are acceptable (what does user see during eventual consistency?)

### 2.3 design.md Should Declare

```markdown
### Eventual Consistency Constraints
- Consistency window: < 5 seconds (99% scenarios)
- User-visible behavior during intermediate state: Display "Processing"
- Convergence failure handling: Trigger compensation/alert
```

---

## 3) Idempotency Testing

### 3.1 Idempotency Test Pattern

```python
# Test: Same message consumed N times, side effect occurs only once
def test_idempotent_message_processing():
    message_id = "msg-001"
    order_id = "order-001"

    # Send same message 3 times
    for _ in range(3):
        send_message(CreateOrderEvent(
            message_id=message_id,
            order_id=order_id,
            amount=100
        ))

    # Wait for processing complete
    wait_for_eventual_consistency(...)

    # Verify: Only 1 order created
    assert order_count(order_id) == 1
    # Verify: Amount correct (not 300)
    assert get_order(order_id).amount == 100
```

### 3.2 Idempotency Checklist

- [ ] Each message has unique `message_id` / `idempotency_key`
- [ ] Test covers "identical message consumed repeatedly"
- [ ] Test covers "retry after partial processing" (simulate mid-processing failure)
- [ ] Verify idempotency key storage (Redis/DB) expiration policy
- [ ] Verify concurrent duplicate message handling (two identical messages arrive simultaneously)

### 3.3 Idempotency Implementation Checks

| Checkpoint | Pass Condition |
|------------|----------------|
| Idempotency key generation | Generated by client, not dependent on server |
| Idempotency key storage | Has persistent storage, has reasonable TTL |
| Idempotency check timing | Check **before** business processing |
| Duplicate request response | Return same result as first time (not error) |

---

## 4) Message Order and Out-of-Order Processing Tests

### 4.1 Out-of-Order Scenarios

| Scenario | Example | Handling Strategy |
|----------|---------|-------------------|
| Event out-of-order | Receive "order shipped" before "order created" | Buffer + reorder / reject + retry |
| Version conflict | Old version update overwrites new version | Version number check (Last-Write-Wins or reject) |
| Causal out-of-order | Child event arrives before parent event | Dependency tracking + delayed processing |

### 4.2 Test Pattern

```python
# Test: Out-of-order messages handled correctly
def test_out_of_order_events():
    order_id = "order-001"

    # Intentionally send in wrong order
    send_message(OrderShippedEvent(order_id=order_id, version=2))
    send_message(OrderCreatedEvent(order_id=order_id, version=1))

    wait_for_eventual_consistency(...)

    # Verify: Final state correct
    order = get_order(order_id)
    assert order.status == "SHIPPED"
    assert order.version == 2
```

### 4.3 Out-of-Order Handling Checklist

- [ ] Define if messages need ordering (global order / partition order / unordered)
- [ ] If ordering needed: Use partition key to guarantee same entity messages in order
- [ ] If out-of-order allowed: Implement version number/timestamp check
- [ ] Test covers "out-of-order arrival" scenario
- [ ] Test covers "version conflict" scenario

---

## 5) Timeout and Retry Testing

### 5.1 Timeout Test Pattern

```python
# Test: Handling when downstream times out
def test_downstream_timeout():
    with mock_timeout(payment_service, timeout_ms=100):
        result = order_service.process_order(order_id)

    # Verify: Degradation behavior after timeout
    assert result.status == "PENDING_PAYMENT"
    assert result.retry_scheduled == True
```

### 5.2 Retry Test Pattern

```python
# Test: Retry logic correct
def test_retry_with_exponential_backoff():
    attempt_times = []

    with mock_failure(payment_service, fail_count=2):
        with capture_attempts(payment_service, attempt_times):
            result = order_service.process_order(order_id)

    # Verify: Retried 3 times (1 initial + 2 retries)
    assert len(attempt_times) == 3
    # Verify: Retry intervals follow exponential backoff
    assert attempt_times[1] - attempt_times[0] >= 100  # First retry
    assert attempt_times[2] - attempt_times[1] >= 200  # Second retry
```

### 5.3 Timeout/Retry Checklist

- [ ] Every async operation has explicit timeout setting
- [ ] Retry has maximum count limit (prevent infinite retry)
- [ ] Retry uses exponential backoff (prevent retry storm)
- [ ] Test covers "degradation after timeout" scenario
- [ ] Test covers "retry success" scenario
- [ ] Test covers "retry exhausted" scenario
- [ ] Verify idempotency during retry (retry doesn't cause duplicate side effects)

---

## 6) Compensating Transaction Testing (Saga Pattern)

### 6.1 Compensation Test Pattern

```python
# Test: Correct compensation on partial failure
def test_saga_compensation():
    order_id = "order-001"

    # Simulate: Inventory deduction succeeds, payment fails
    with mock_success(inventory_service):
        with mock_failure(payment_service):
            result = order_service.create_order(order_id)

    wait_for_eventual_consistency(...)

    # Verify: Order status is failed
    assert get_order(order_id).status == "FAILED"
    # Verify: Inventory rolled back
    assert get_inventory_reserved(order_id) == 0
    # Verify: Compensation record exists
    assert compensation_log_exists(order_id, "INVENTORY_ROLLBACK")
```

### 6.2 Compensation Test Checklist

- [ ] Every compensatable operation has corresponding compensation operation
- [ ] Compensation operations themselves are idempotent
- [ ] Test covers "failure at each node in the chain"
- [ ] Test covers "compensation operation fails" scenario
- [ ] Verify compensation operation execution order (reverse order)
- [ ] Verify compensation logs/audit records

---

## 7) Test Double Design

### 7.1 Message Queue Test Doubles

| Double Type | Purpose | Implementation Suggestion |
|-------------|---------|---------------------------|
| In-Memory Queue | Unit/integration tests | Memory queue, synchronous processing |
| Controllable Queue | Fault injection | Can control delay, loss, duplication |
| Record & Replay | Regression tests | Record production messages, offline replay |

### 7.2 Test Double Checklist

- [ ] Test double has same interface as real implementation
- [ ] Can control message delay
- [ ] Can control message loss
- [ ] Can control message duplication
- [ ] Can control message out-of-order
- [ ] Can inject processing failure

---

## 8) verification.md Supplement Template

In `verification.md` test plan, if involving async systems, add the following checks:

```markdown
### Async System Test Checks (If Applicable)

#### Eventual Consistency
- [ ] Define consistency window: < X seconds
- [ ] Test covers "state convergence success"
- [ ] Test covers "state convergence timeout"

#### Idempotency
- [ ] Message contains `idempotency_key`
- [ ] Test covers "duplicate message processed only once"
- [ ] Test covers "concurrent duplicate messages"

#### Message Order
- [ ] Declare ordering requirement: global order / partition order / unordered
- [ ] Test covers "out-of-order message handling"

#### Timeout and Retry
- [ ] Declare timeout: X ms
- [ ] Declare retry strategy: max N times, exponential backoff
- [ ] Test covers "timeout degradation"
- [ ] Test covers "retry success/exhausted"

#### Compensating Transactions (If Applicable)
- [ ] Define compensation operations
- [ ] Test covers "compensation on partial failure"
- [ ] Verify compensation operation idempotency
```

---

## 9) Common Flaky Test Patterns and Fixes

| Flaky Pattern | Cause | Fix Method |
|---------------|-------|------------|
| Fixed sleep | Time insufficient or excessive | Use polling wait + timeout |
| Depend on message order | Parallel consumption causes out-of-order | Use idempotent design or explicit ordering |
| Shared test state | Tests interfere with each other | Each test uses independent data |
| Time-sensitive assertions | Depends on system clock | Inject controllable clock |
| Resource contention | Port/file conflicts | Use dynamic allocation or isolated environment |
