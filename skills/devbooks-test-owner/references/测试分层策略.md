# 测试分层策略

借鉴 VS Code 的测试组织模式，本文档定义了测试分层的最佳实践。

---

## 1) 测试金字塔原则

### 理想比例

| 层级 | 比例 | 特点 | 执行频率 |
|------|------|------|----------|
| 单元测试 | 70% | 快速、隔离、聚焦 | 每次提交 |
| 集成测试 | 20% | 模块边界、真实依赖 | 每次 PR |
| E2E 测试 | 10% | 端到端、用户视角 | 每次合并 |

### 各层职责

**单元测试**：
- 测试单个函数/类的行为
- 完全隔离，无外部依赖
- 执行速度 < 5s/文件
- 覆盖所有边界条件

**集成测试**：
- 测试模块间交互
- 可使用测试数据库/缓存
- 执行速度 < 30s/文件
- 覆盖 API 契约

**E2E 测试**：
- 测试完整用户流程
- 使用真实环境
- 执行速度 < 60s/场景
- 只覆盖关键路径

---

## 2) 测试命名约定

### 文件命名

```
src/
├── user/
│   ├── user.service.ts
│   └── test/
│       └── user.service.test.ts    # 单元测试（紧邻源码）

tests/
├── unit/                           # 备选：集中式单元测试
│   └── user.service.test.ts
├── integration/
│   └── user.api.integrationTest.ts # 集成测试
├── e2e/
│   └── user-flow.e2e.ts            # E2E 测试
├── contract/
│   └── user.api.contract.ts        # 契约测试
└── smoke/
    └── health.smoke.ts             # 烟雾测试
```

### 测试用例命名

```typescript
// Good: 描述行为和预期结果
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a new user with valid data', () => {});
    it('should throw ValidationError when email is invalid', () => {});
    it('should return existing user when email already exists', () => {});
  });
});

// Bad: 模糊的描述
describe('UserService', () => {
  it('test1', () => {});
  it('works', () => {});
});
```

---

## 3) 测试隔离策略

### 单元测试隔离

```typescript
// 使用 mock 隔离外部依赖
import { mock, MockProxy } from 'jest-mock-extended';

describe('UserService', () => {
  let userRepo: MockProxy<UserRepository>;
  let service: UserService;

  beforeEach(() => {
    userRepo = mock<UserRepository>();
    service = new UserService(userRepo);
  });

  it('should call repository save', async () => {
    userRepo.save.mockResolvedValue({ id: '1', name: 'test' });
    await service.createUser({ name: 'test' });
    expect(userRepo.save).toHaveBeenCalledWith({ name: 'test' });
  });
});
```

### 集成测试隔离

```typescript
// 使用 beforeEach/afterEach 清理
describe('User API Integration', () => {
  let testDb: TestDatabase;

  beforeAll(async () => {
    testDb = await TestDatabase.create();
  });

  beforeEach(async () => {
    await testDb.clean(); // 每个测试前清理
  });

  afterAll(async () => {
    await testDb.destroy();
  });

  it('should create user via API', async () => {
    const response = await request(app)
      .post('/users')
      .send({ name: 'test' });
    expect(response.status).toBe(201);
  });
});
```

### E2E 测试隔离

```typescript
// 使用独立的测试环境
describe('User Registration Flow', () => {
  let browser: Browser;
  let page: Page;

  beforeAll(async () => {
    browser = await chromium.launch();
  });

  beforeEach(async () => {
    page = await browser.newPage();
    await seedTestData(); // 准备测试数据
  });

  afterEach(async () => {
    await page.close();
    await cleanupTestData(); // 清理测试数据
  });

  afterAll(async () => {
    await browser.close();
  });
});
```

---

## 4) 测试稳定性保障

### 禁止提交的模式

```bash
# pre-commit hook 检查
check_test_only() {
  if rg -l '\.(only|skip)\(' tests/ src/**/test/; then
    echo "error: found .only() or .skip() in tests" >&2
    exit 1
  fi
}
```

### Flaky 测试处理

```typescript
// 临时标记 flaky 测试（必须附带 issue 链接）
describe.skip('Flaky test - see #123', () => {
  // TODO: Fix flaky test by 2024-01-15
});

// 或使用重试（不推荐，应修复根因）
it('sometimes fails', async () => {
  // jest-retries 或 mocha-retry
}, { retries: 2 });
```

### 超时设置

```typescript
// 合理的超时设置
jest.setTimeout(5000); // 单元测试默认 5s

describe('Integration Tests', () => {
  beforeAll(() => {
    jest.setTimeout(30000); // 集成测试 30s
  });
});
```

---

## 5) 测试覆盖率策略

### 覆盖率目标

| 指标 | 最低要求 | 推荐目标 |
|------|----------|----------|
| 行覆盖率 | 70% | 80%+ |
| 分支覆盖率 | 60% | 70%+ |
| 函数覆盖率 | 80% | 90%+ |

### 覆盖率例外

```typescript
// 明确标记不需要覆盖的代码
/* istanbul ignore next */
function debugOnly() {
  // 仅调试用，不需要测试
}

/* istanbul ignore if */
if (process.env.NODE_ENV === 'development') {
  // 开发环境特定代码
}
```

---

## 6) 测试反脆弱策略（借鉴 VS Code Audit.md）

### 避免脆弱的选择器

```typescript
// Bad: 依赖 CSS 类名（容易因样式重构而失败）
await page.click('.btn-primary');

// Bad: 依赖文本内容（容易因国际化而失败）
await page.click('text=Submit');

// Good: 使用 data-testid
await page.click('[data-testid="submit-button"]');

// Good: 使用 role
await page.click('role=button[name="Submit"]');
```

### 避免脆弱的断言

```typescript
// Bad: 精确匹配（容易因格式变化而失败）
expect(result.createdAt).toBe('2024-01-01T00:00:00.000Z');

// Good: 类型断言
expect(result.createdAt).toBeInstanceOf(Date);

// Good: 模糊匹配
expect(result.message).toContain('success');
```

---

## 7) 测试审查检查清单

在 Code Review 时检查：

- [ ] 测试是否遵循命名约定？
- [ ] 单元测试是否完全隔离？
- [ ] 集成测试是否有清理逻辑？
- [ ] 是否有 `.only()` 或 `.skip()` 残留？
- [ ] 超时设置是否合理？
- [ ] 是否避免了脆弱的选择器？
- [ ] 新增代码是否有对应的测试？
- [ ] 测试是否覆盖了边界条件？
