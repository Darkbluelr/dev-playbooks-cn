# DevBooks：单人可完成大型项目的代理式 AI 编程框架（Skills + 上下文协议适配器）

适用工具：Claude Code / Codex CLI  
目标：用“协议化上下文 + 可执行验收锚点 + 角色隔离 + 影响分析”把大项目变更做成可控、可追溯、可归档的闭环。

---

## 0) 核心原则（强制）

- **协议优先**：把"当前真理 / 变更包 / 归档"落盘在项目里（而不是只存在于聊天）。
- **锚点优先**：完成的定义来自 `tests/`、静态检查、构建与证据（而不是 AI 自评）。
- **角色隔离**：Test Owner 与 Coder 必须独立对话/独立实例；Coder 禁止修改 `tests/**`。
- **结构守门**：遇到"代理指标驱动"的要求必须停线评估，优先复杂度/耦合/依赖方向/测试质量。
- **真理源分离**：`<truth-root>` 是唯一真理源（只读参考），`<change-root>/<change-id>/` 是临时工作区（可任意试错）；归档 = 将派生数据合并回真理源。
- **幂等性设计**：所有验证/检查类操作必须幂等（不修改文件）；生成类操作需明确"覆盖/增量"行为。

---

## 1) 一次性安装（让所有项目都可用）

在本仓库根目录执行：

```bash
./scripts/install-skills.sh
```

如果你主要用 Codex，并希望用更稳定的“命令入口”跑 DevBooks+OpenSpec 的质量优先流程，再额外执行：

```bash
./scripts/install-skills.sh --with-codex-prompts
```

这会把 3 个 Codex prompt 安装到 `$CODEX_HOME/prompts`（默认 `~/.codex/prompts/`），对应命令：
- `/devbooks-openspec-proposal`
- `/devbooks-openspec-apply`
- `/devbooks-openspec-archive`

安装位置：
- Claude Code：`~/.claude/skills/devbooks-*`
- Codex CLI：`$CODEX_HOME/skills/devbooks-*`（默认 `~/.codex/skills/devbooks-*`）

安装后重启 Claude Code / Codex CLI，然后在对话里问：
- `What Skills are available?`（或“有哪些 Skills 可用？”）

更新流程：`git pull` 后再次执行 `./scripts/install-skills.sh` 即可覆盖安装。

---

## 2) 每个项目一次性接线（适配你的上下文协议）

DevBooks Skills 本身不依赖 OpenSpec；它们只依赖两个目录根的定义：
- `<truth-root>`：当前真理目录根（默认建议 `specs/`）
- `<change-root>`：变更包目录根（默认建议 `changes/`）

接线的目的：把这两个目录根、DoD、角色隔离、Skills 索引写进项目的“上下文协议指路牌文件”里。

### A) 如果你的项目使用 OpenSpec

- 入口：`setup/openspec/README.md`
- 让 AI 自动接线：`setup/openspec/安装提示词.md`
- 可复制模板：`setup/openspec/OpenSpec集成模板（project.md 与 AGENTS附加块）.md`

OpenSpec 映射关系：
- `<truth-root>` → `openspec/specs/`
- `<change-root>` → `openspec/changes/`

### B) 如果你使用其他上下文协议（或没有协议）

- 入口：`setup/template/DevBooks集成模板（协议无关）.md`
- 让 AI 自动接线：`setup/template/安装提示词.md`

---

## 3) 日常变更闭环（一次 change package）

统一产物落点（强约束）：`<change-root>/<change-id>/`。

### 推荐：质量优先闭环（兼容 OpenSpec）

> 目标：让“高质量代码”变成默认产物，而不是靠运气。

1) Proposal（提案阶段，禁止写代码）
   - 产物：`proposal.md`（必须），`design.md`（非小改动必须），`tasks.md`（必须）
   - 若存在**对外行为/契约/数据不变量**变化：补 `specs/**`（spec delta）
   - 照抄入口（推荐：Codex CLI）：
     - 直接粘贴一行：`/devbooks-openspec-proposal <把你的需求贴在这里>`
     - 示例（可照抄改字）：`/devbooks-openspec-proposal 给“订单查询”新增分页与排序（保持旧参数兼容），并补齐契约测试与回滚策略`
   - 照抄入口（Claude Code：显式点名 Skills，保证触发；只需填“我的需求”）：
     ```text
     你在一个 OpenSpec 项目里工作。请先阅读 `openspec/project.md`，并按 OpenSpec 的 proposal 阶段执行（禁止写实现代码）。

     现在请按顺序使用这些 DevBooks Skills（点名调用），只产出/更新变更包文档：
     1) 使用 `devbooks-proposal-author`：
        - 生成一个语义清晰的 `<change-id>`（动词开头），并在输出里重复 3 次
        - 写：`openspec/changes/<change-id>/proposal.md`
     2) （可选）当“跨模块/影响不清晰/要改很多文件”时，使用 `devbooks-impact-analysis`：
        - 输出影响分析，并把结论回填到 `proposal.md` 的 Impact 部分
     3) （可选）当“争议大/取舍多/风险高”时，使用 `devbooks-proposal-debate-workflow`：
        - Author/Challenger/Judge 三角色隔离
        - 把裁决写回 `proposal.md` 的 Decision Log（状态必须为 Approved/Revise/Rejected，禁止 Pending）
     4) 使用 `devbooks-design-doc`：
        - 写：`openspec/changes/<change-id>/design.md`（只写 What/Constraints + AC-xxx，不写实现步骤）
     5) （可选）当“对外行为/契约/数据不变量”变化时，使用 `devbooks-spec-delta`：
        - 写：`openspec/changes/<change-id>/specs/<capability>/spec.md`
     6) 使用 `devbooks-implementation-plan`：
        - 写：`openspec/changes/<change-id>/tasks.md`（只从 design/spec 推导）

     额外要求（必须）：
     - 在 `proposal.md` 的 Impact 里必须写清：`价值信号与观测口径`、`价值流瓶颈假设（排队点）`（不会写就填“无”）
     - 最后运行：`openspec validate <change-id> --strict` 并修复所有问题

     我的需求是：
     <一句话需求 + 背景 + 约束>
     ```
   - 你只需要记住一个东西：`change-id`
     - 它就是本次变更包目录名：`openspec/changes/<change-id>/`
     - 后续 apply/review/archive 都只需要把 `<change-id>` 替换成这个值

2) Apply（实现阶段，强制角色隔离）
   - Test Owner（独立对话/独立实例）：`devbooks-test-owner` → 写 `verification.md` + tests，并先跑出 **Red**
   - Coder（独立对话/独立实例）：`devbooks-coder` → 按 `tasks.md` 实现，让闸门 **Green**（禁改 tests）
   - 照抄入口（必须开 2 个独立对话/独立实例）：
     - Test Owner：`/devbooks-openspec-apply test-owner <change-id>`
     - Coder：`/devbooks-openspec-apply coder <change-id>`
     - 可选 Reviewer：`/devbooks-openspec-apply reviewer <change-id>`
     - 示例（把 change-id 改成你 proposal 阶段产出的那个）：`/devbooks-openspec-apply test-owner add-order-list-pagination`
   - 照抄入口（Claude Code：Test Owner 专用，对话 A；只需填 change-id）：
     ```text
     你现在是 Test Owner（必须独立对话/独立实例）。请点名使用 `devbooks-test-owner`，按 OpenSpec apply 阶段执行：
     - 先读：`openspec/project.md`、`openspec/changes/<change-id>/proposal.md`、`design.md`、`tasks.md`、本次 `specs/**`（如有）
     - 产出：
       - `openspec/changes/<change-id>/verification.md`（含追溯矩阵）
       - `tests/**`（按仓库惯例）
       - （证据）`openspec/changes/<change-id>/evidence/**`
     - 要求：
       - 必须先跑出 Red 基线（证明当前不满足 AC），并把失败输出/截图/日志写入 evidence
       - 在 `verification.md` 的 `G) 价值流与度量` 里写清观测口径（不会写就填“无”）
     - 最后运行：`openspec validate <change-id> --strict`
     ```
   - 照抄入口（Claude Code：Coder 专用，对话 B；只需填 change-id）：
     ```text
     你现在是 Coder（必须独立对话/独立实例）。请点名使用 `devbooks-coder`，按 OpenSpec apply 阶段执行：
     - 先读：`openspec/project.md`、`openspec/changes/<change-id>/proposal.md`、`design.md`、`tasks.md`、`verification.md`（如已存在）
     - 严格按 `tasks.md` 实现；每完成一项再勾选 `- [x]`
     - **禁止修改** `tests/**`；如需调整测试只能交还 Test Owner
     - 以 tests/静态检查/build 为唯一完成判据；必要时把关键输出落盘到 `openspec/changes/<change-id>/evidence/`
     ```
   - Apply 阶段可选项（按需追加一句即可）：
     - 当 Coder 发现“设计缺口/范围不清/守门冲突”：`停止实现，使用 devbooks-design-backport 把缺口回写 openspec/changes/<change-id>/design.md`

3) Review（评审阶段）
   - `devbooks-code-review`：输出可执行的坏味道/依赖/一致性建议（不争论业务正确性）
   - 照抄入口（Codex CLI）：`/devbooks-openspec-apply reviewer <change-id>`
   - 照抄入口（Claude Code；只需填 change-id）：
     ```text
     请点名使用 `devbooks-code-review`，对 `openspec/changes/<change-id>/` 这次变更做 Reviewer 审查：
     - 重点看：耦合/依赖方向/复杂度/一致性/可测试性/坏味道
     - 不讨论业务正确性；只给可执行建议与风险点
     ```
   - Review 阶段可选项（按需追加一句即可）：
     - 当你认为“边界/依赖方向/模块地图发生变化”：`同时使用 devbooks-c4-map 更新 openspec/specs/architecture/c4.md`

4) Archive（归档阶段）
   - 若本次改了 specs：`devbooks-spec-gardener` 先修剪 `(<truth-root>/**)`（去重/合并/删除过时），再按协议归档合并
   - 照抄入口（Codex CLI）：`/devbooks-openspec-archive <change-id>`
   - 照抄入口（Claude Code；只需填 change-id）：
     ```text
     现在进入 OpenSpec archive 阶段（归档关账）。请按顺序执行：
     1) （可选）如果本次有 spec deltas：先点名使用 `devbooks-spec-gardener` 修剪 `openspec/specs/**`
     2) 运行：`openspec archive <change-id> --yes`
     3) 运行：`openspec validate --strict`
     4) 输出：归档摘要 + specs 更新点
     ```
   - Archive 阶段可选项（按需追加一句即可）：
     - 当实现过程中出现“临时决策/新约束”但没进设计：`归档前先用 devbooks-design-backport 回写 design.md`

提示：
- 如果你用 Codex：优先使用 `/devbooks-openspec-proposal`、`/devbooks-openspec-apply`、`/devbooks-openspec-archive` 作为入口（更稳定地把流程与角色隔离跑完整）。
- 纯"坏味道重构/不改外部行为"通常不需要 spec delta，但必须用测试把现状锁住（characterization / regression）。
- 如果你不确定下一步该用哪个 Skill：直接说"使用 `devbooks-router` 帮我路由下一步并给出产物落点"。
- Skills 触发不稳定时，在请求里点名（例如"使用 devbooks-design-doc 写设计文档"）。

### 可选：Prototype 模式（Plan to Throw One Away）

> 来源：《人月神话》第11章"未雨绸缪" — "第一个开发的系统并不合用...为舍弃而计划"

当技术方案不确定、需要快速验证可行性时，可使用原型模式：

1) 创建原型：
   - 在 proposal 阶段输入口令 `--prototype` 或说"先做原型/spike/快速验证"
   - 骨架命令：`change-scaffold.sh <change-id> --prototype ...`
   - 产物目录：`<change-root>/<change-id>/prototype/`

2) 原型轨道约束：
   - Test Owner 使用 `devbooks-test-owner --prototype`：产出**表征测试**（记录实际行为）而非验收测试，**不需要 Red 基线**
   - Coder 使用 `devbooks-coder --prototype`：输出到 `prototype/src/`，允许绕过 lint/复杂度阈值，**禁止直接落到仓库 src/**
   - 角色隔离不变：Test Owner 与 Coder 仍必须独立对话/独立实例

3) 原型提升到生产：
   - 前置条件：生产级 `design.md` + 验收测试 `verification.md` + `PROTOTYPE.md` 检查清单完成
   - 提升命令：`prototype-promote.sh <change-id> ...`

4) 原型丢弃：
   - 记录学习到的关键洞察到 `proposal.md` 的 Decision Log
   - 删除 `prototype/` 目录

### 可选：把重复且需要确定性的步骤脚本化（推荐）

DevBooks 的确定性脚本位于已安装 Skill 的 `scripts/` 目录，你可以直接在终端运行（减少上下文占用、提升稳定性）：

- Codex：`DEVBOOKS_SCRIPTS="${CODEX_HOME:-$HOME/.codex}/skills/devbooks-delivery-workflow/scripts"`
- Claude：`DEVBOOKS_SCRIPTS="$HOME/.claude/skills/devbooks-delivery-workflow/scripts"`

常用命令（devbooks-delivery-workflow）：
- 生成变更包骨架：`"$DEVBOOKS_SCRIPTS/change-scaffold.sh" <change-id> --project-root "$(pwd)" --change-root <change-root> --truth-root <truth-root>`
- 生成原型骨架：`"$DEVBOOKS_SCRIPTS/change-scaffold.sh" <change-id> --prototype --project-root "$(pwd)" --change-root <change-root> --truth-root <truth-root>`
- 一键校验（归档前）：`"$DEVBOOKS_SCRIPTS/change-check.sh" <change-id> --mode strict --project-root "$(pwd)" --change-root <change-root> --truth-root <truth-root>`
- 证据落盘：`"$DEVBOOKS_SCRIPTS/change-evidence.sh" <change-id> --label tests --project-root "$(pwd)" --change-root <change-root> -- <test-command>`
- 生成 spec delta 骨架：`"$DEVBOOKS_SCRIPTS/change-spec-delta-scaffold.sh" <change-id> <capability> --project-root "$(pwd)" --change-root <change-root>`
- 生成 codemod 脚本骨架：`"$DEVBOOKS_SCRIPTS/change-codemod-scaffold.sh" <change-id> --name <codemod-name> --project-root "$(pwd)" --change-root <change-root>`
- 护栏检查（基础）：`"$DEVBOOKS_SCRIPTS/guardrail-check.sh" <change-id> --project-root "$(pwd)" --change-root <change-root>`
- 护栏检查（架构合规）：`"$DEVBOOKS_SCRIPTS/guardrail-check.sh" <change-id> --project-root "$(pwd)" --change-root <change-root> --truth-root <truth-root> --check-layers --check-cycles --check-hotspots`
- 卫生检查（临时文件/进程）：`"$DEVBOOKS_SCRIPTS/hygiene-check.sh" <change-id> --project-root "$(pwd)" --change-root <change-root>`
- 原型提升到生产：`"$DEVBOOKS_SCRIPTS/prototype-promote.sh" <change-id> --project-root "$(pwd)" --change-root <change-root>`

其他 Skill 脚本：
- 隐式变更检测（devbooks-contract-data）：`"$HOME/.claude/skills/devbooks-contract-data/scripts/implicit-change-detect.sh" --project-root "$(pwd)"`
- 提案对辩检查（devbooks-proposal-debate-workflow）：`"$HOME/.claude/skills/devbooks-proposal-debate-workflow/scripts/proposal-debate-check.sh" <change-id> --project-root "$(pwd)" --change-root <change-root>`
- 熵度量采集（devbooks-entropy-monitor）：`"$HOME/.claude/skills/devbooks-entropy-monitor/scripts/entropy-measure.sh" --project-root "$(pwd)"`
- 熵度量报告（devbooks-entropy-monitor）：`"$HOME/.claude/skills/devbooks-entropy-monitor/scripts/entropy-report.sh" --output report.md`
- COD 模型增量更新（devbooks-brownfield-bootstrap）：`"$HOME/.claude/skills/devbooks-brownfield-bootstrap/scripts/cod-update.sh" --project-root "$(pwd)" --truth-root <truth-root>`
- 子图缓存管理（devbooks-impact-analysis）：`"$HOME/.claude/skills/devbooks-impact-analysis/scripts/graph-cache.sh" status`
- 联邦契约检查（devbooks-federation）：`"$HOME/.claude/skills/devbooks-federation/scripts/federation-check.sh" --project-root "$(pwd)"`

OpenSpec 项目示例（映射 `<change-root>/<truth-root>`）：
- `--change-root openspec/changes --truth-root openspec/specs`

### 可选：从“写码速度”升级到“价值流”（推荐）

每个变更包都建议显式写清（不会写就填“无”）：
- `proposal.md` 的 `Impact`：`价值信号与观测口径`、`价值流瓶颈假设（排队点）`
- `verification.md` 的 `G) 价值流与度量`：DORA/稳定性/业务信号 + evidence 链接（建议落到 `evidence/`）

---

## 4) 存量项目初始化（当 `<truth-root>` 为空）

使用 `devbooks-brownfield-bootstrap`：
- 先选基线范围（对外契约优先 / 关键链路优先 / 模块边界优先）
- 一次性产出项目画像、术语表（可选）、基线 specs 与最小验证锚点
- **COD 模型**（借鉴 Augment Code）：自动生成模块依赖图、技术债热点、领域概念等"代码地图"产物

如需激活图基代码理解能力（调用图、影响分析等），使用 `devbooks-index-bootstrap` 生成 SCIP 索引。

### 可选：自动化配置（推荐）

为了实现"无感集成"，可以配置以下自动化：

1. **Git Hooks 自动索引**：每次 commit/pull 后自动更新 SCIP 索引 + COD 模型
   ```bash
   bash setup/hooks/install-git-hooks.sh /path/to/your/project
   ```

2. **Claude Code Hooks**：每次对话自动注入项目上下文
   - 参考 `setup/hooks/claude-hooks-template.yaml`

3. **自动 Skill 路由**：AI 根据意图自动选择 Skill
   - 参考 `setup/openspec/OpenSpec集成模板（project.md 与 AGENTS附加块）.md` 中的"自动 Skill 路由规则"

4. **CI/CD 集成**：PR 时自动运行架构合规检查
   ```bash
   cp templates/ci/devbooks-guardrail.yml .github/workflows/
   cp templates/ci/devbooks-cod-update.yml .github/workflows/
   ```
   - 复杂度检查、热点检查、分层违规、循环依赖检测
   - 详细说明：`templates/ci/README.md`

5. **跨仓库联邦**：多仓库项目的契约同步与影响分析
   ```bash
   cp templates/federation.yaml .devbooks/federation.yaml
   ```
   - 详细说明：`skills/devbooks-federation/SKILL.md`

详细说明：`setup/hooks/README.md`

---

## 5) MCP（可选）

MCP 配置与排障：
- Claude Code：`mcp/mcp_claude.md`
- Codex CLI：`mcp/mcp_codex.md`
- 服务器清单：`mcp/mcp-servers.md`

---

## 6) Skills 索引（devbooks-*）

角色类：
- `devbooks-router`【新增：图索引健康检查】
- `devbooks-proposal-author` / `devbooks-proposal-challenger` / `devbooks-proposal-judge`
- `devbooks-impact-analysis`【新增：图基/文本双模式】 / `devbooks-design-doc` / `devbooks-spec-contract`【新：合并了 spec-delta + contract-data】 / `devbooks-implementation-plan`
- `devbooks-test-owner`【新增：输出管理】 / `devbooks-coder`【新增：断点续做 + 输出管理 + 热点感知】 / `devbooks-code-review`【新增：热点优先审查】 / `devbooks-spec-gardener`
- `devbooks-c4-map` / `devbooks-design-backport`

工作流类：
- `devbooks-proposal-debate-workflow` / `devbooks-delivery-workflow`【新增：架构合规检查选项】
- `devbooks-brownfield-bootstrap`【新增：COD 模型生成 + 增量更新】
- `devbooks-index-bootstrap`【新】：自动检测项目语言并生成 SCIP 索引，激活图基代码理解能力
- `devbooks-federation`【新】：跨仓库联邦分析与契约同步，支持多仓库项目的影响分析

度量类：
- `devbooks-entropy-monitor`：定期采集系统熵度量（结构熵/变更熵/测试熵/依赖熵），生成量化报告，当指标超阈值时建议重构
