# DevBooks 使用指南

> 本指南介绍 DevBooks 的最佳实践和推荐工作流程。

---

## 快速开始：不知道怎么用？

**如果你不确定如何使用 DevBooks，最简单的方式是：**

```bash
/devbooks:delivery
```

这是 DevBooks 的唯一入口：会先路由 `request_kind`，再按“最小充分闭环”编排执行。

### delivery-workflow 会做什么？

Delivery 会根据 `request_kind` 选择需要的节点（不会强制跑固定阶段表），常见节点包括：

1. **Proposal（提案）** - 分析需求，撰写变更提案
2. **Design（设计）** - 定义功能需求和验收标准
3. **Spec（规格）** - 定义对外行为契约
4. **Plan（计划）** - 制定实现计划和任务拆解
5. **Test（测试）** - 编写验收测试（独立对话）
6. **Implement（实现）** - 实现功能（独立对话）
7. **Review（评审）** - 代码评审
8. **Archive（归档）** - 归档变更包

> 高风险/史诗级变更提示：当 `risk_level=high` 或 `request_kind=epic` 时，必须先执行 `/devbooks:knife` 生成 Knife Plan；严格闸门会把 Knife Plan 作为 G3 强制项校验（缺失会阻断）。

**适用场景**：
- 新功能开发
- 重大重构
- 不熟悉 DevBooks 工作流
- 希望自动化完整流程

**注意**：需要 AI 工具支持子 Agent（如 Claude Code）。

### P3-3 行动规范（必读）

为避免长流程中的“串线/漏落盘/忘归档/假完成”，执行 `/devbooks:delivery` 前建议先通读：

- `skills/devbooks-delivery-workflow/references/编排禁令与阶段表.md`（含 **P3-3 行动规范**：主代理只编排、产物编号落盘、多 change 防串线、跑完 Archiver 才算结束等）

---

## 目录

- [快速开始](#快速开始不知道怎么用)
- [核心理念](#核心理念)
- [工作流程](#工作流程)
- [最佳实践](#最佳实践)
- [常见场景](#常见场景)
- [质量保证](#质量保证)
- [故障排查](#故障排查)

---

## 定位与文本规范

DevBooks 本体是本地工作流工具，保留少量自检脚本作为护栏；不提供 MCP 支持。
DevBooks 聚焦协议、工作流、文本规范的统一描述，强调流程可追溯与可验证。

约束：指导内容需要保持可扫描与可复用。
取舍：减少冗长叙述，优先呈现结构化要点。
影响：协作共识更稳定，查阅成本下降。

---

## 核心理念

### 1. 角色隔离

**Test Owner 与 Coder 必须在独立对话中工作**

这是 DevBooks 的核心约束，不是建议：

- **Test Owner**：根据设计/规格编写验收测试，先跑出 Red 基线
- **Coder**：根据任务实现功能，不能修改 `tests/` 目录
- **完成标准**：测试通过 + 构建成功，而非 AI 自评

**隔离状态对照**

| 未隔离状态 | 隔离状态 |
|-----------|---------|
| 测试沦为"通过性测试" | 测试真正验证规格 |
| AI 自评"已完成" | 基于证据的完成 |
| 边界条件遗漏 | 独立视角发现问题 |

### 2. 规格驱动

**所有代码必须追溯到 AC-xxx（验收标准）**

```
需求 → Proposal → Design (AC-001, AC-002) → Spec → Tasks → Tests → Code
```

- 设计文档定义 What/Constraints + AC-xxx
- 规格文档定义对外行为契约
- 任务文档定义实现步骤
- 验证文档定义测试策略

### 3. 证据优先

**完成由证据定义，而非 AI 声明**

必需的证据：
- 测试通过（Green 证据）
- 构建成功
- 静态检查通过
- 任务完成率 100%

---

## 工作流程

### 完整闭环

```
1. Proposal（提案）
   ↓
2. Design（设计）
   ↓
3. Spec（规格）
   ↓
4. Plan（计划）
   ↓
5. Test（测试）
   ↓
6. Implement（实现）
   ↓
7. Review（评审）
   ↓
8. Archive（归档）
```

### 快速开始（新功能）

```bash
# 1. 创建提案
/devbooks-proposal-author

# 2. 编写设计
/devbooks-design-doc

# 3. 定义规格
/devbooks-spec-contract

# 4. 制定计划
/devbooks-implementation-plan

# 5. 编写测试（独立对话）
/devbooks-test-owner

# 6. 实现功能（独立对话）
/devbooks-coder

# 7. 代码评审
/devbooks-reviewer

# 8. 归档变更
/devbooks-archiver
```

### 存量项目初始化

```bash
# 生成项目画像、术语表、基线规格
/devbooks-brownfield-bootstrap
```

---

## 最佳实践

### 1. 提案阶段

**使用三角对辩机制**

- **Author**：撰写提案（Why/What/Impact）
- **Challenger**：质疑提案（风险/遗漏/不一致）
- **Judge**：裁决提案（Approved/Revise/Rejected）

```bash
# 1. 撰写提案
/devbooks-proposal-author

# 2. 质疑提案
/devbooks-proposal-challenger

# 3. 裁决提案
/devbooks-proposal-judge
```

**提案结构要点**

- **Why**：变更背景与目标
- **What**：变更范围与内容
- **Impact**：影响范围、风险、最小改动面
- **Open Questions**：未解决的问题

### 2. 设计阶段

**只写 What/Constraints，不写 How**

设计文档应该包含：
- 要做什么（What）
- 约束条件（Constraints）
- 验收标准（AC-xxx）
- C4 架构图（可选）

**不应该包含**：
- 实现步骤
- 代码示例
- 技术细节

### 3. 规格阶段

**定义对外行为契约**

规格文档应该包含：
- API 接口定义
- 数据模型 Schema
- 兼容性策略
- 迁移方案
- Contract Tests

### 4. 测试阶段

**Test Owner 先跑出 Red 基线**

```bash
# 在独立对话中
/devbooks-test-owner

# 验证 Red 基线
npm test  # 应该失败
```

**测试策略**

- **Contract Tests**：验证对外契约
- **Fitness Tests**：验证架构约束
- **Unit Tests**：验证单元逻辑
- **Integration Tests**：验证集成场景

### 5. 实现阶段

**Coder 严格按 tasks.md 实现**

```bash
# 在独立对话中
/devbooks-coder

# 验证 Green 证据
npm test  # 应该通过
npm run build  # 应该成功
```

**Coder 的约束**

- 不能修改 `tests/` 目录
- 不能修改设计文档
- 完成标准是测试通过，而非自评

### 6. 评审阶段

**Reviewer 只审查可维护性**

```bash
/devbooks-reviewer
```

**评审维度**

- 可读性
- 一致性
- 依赖健康
- 坏味道
- 架构约束

**不评审**：业务正确性（由测试保证）

### 7. 归档阶段

**自动化闭环**

```bash
/devbooks-archiver
```

归档流程：
1. 自动回写设计（Design Backport）
2. 规格合并到真理（Spec Merge）
3. 文档同步检查（Docs Consistency）
4. 变更包归档移动

#### 发布前自检（维护者：发布包/入口）

在发布 npm 包（或做发布前审计）前，先跑一遍“入口/packlist”自检，并把输出作为证据落盘：

```bash
# 一键自检入口（slash commands + npm metadata）
bash skills/devbooks-delivery-workflow/scripts/verify-all.sh --project-root "/path/to/dev-playbooks-cn"

# 发布边界（最终以 packlist 为准）
npm pack --dry-run
```

如需把输出纳入变更包证据（推荐）：

```bash
bash skills/devbooks-delivery-workflow/scripts/change-evidence.sh <change-id> \
  --project-root "/path/to/dev-playbooks-cn" \
  --change-root dev-playbooks/changes \
  --out gates/npm-pack-dry-run.log -- npm pack --dry-run
```

#### 协议 v1.1 覆盖报告与风险证据（strict/archive 阻断项）

在 `strict/archive` 模式下，覆盖报告与风险证据属于阻断项（缺失会失败）：

```bash
# v1.1 MUST/SHOULD 覆盖报告（用于 strict 闸门）
bash scripts/generate-protocol-v1.1-coverage-report.sh \
  --project-root "/path/to/dev-playbooks-cn" \
  --change-id <change-id> \
  --change-root dev-playbooks/changes

# 依赖审计（中/高风险变更通常要求）
bash scripts/dependency-audit.sh \
  --project-root "/path/to/dev-playbooks-cn" \
  --output dev-playbooks/changes/<change-id>/evidence/risks/dependency-audit.log
```

产物路径（变更包内）：
- `evidence/gates/protocol-v1.1-coverage.report.json`
- `evidence/risks/dependency-audit.log`

---

## 常见场景

### 场景 1：新增功能

```bash
# 1. 提案
/devbooks-proposal-author

# 2. 设计
/devbooks-design-doc

# 3. 规格
/devbooks-spec-contract

# 4. 计划
/devbooks-implementation-plan

# 5. 测试（独立对话）
/devbooks-test-owner

# 6. 实现（独立对话）
/devbooks-coder

# 7. 评审
/devbooks-reviewer

# 8. 归档
/devbooks-archiver
```

### 场景 2：Bug 修复

```bash
# 1. 影响分析
/devbooks-impact-analysis

# 2. 设计修复方案
/devbooks-design-doc

# 3. 补充测试（独立对话）
/devbooks-test-owner

# 4. 修复实现（独立对话）
/devbooks-coder

# 5. 归档
/devbooks-archiver
```

### 场景 3：重构

```bash
# 1. 提案（描述重构范围）
/devbooks-proposal-author

# 2. 设计（定义重构目标）
/devbooks-design-doc

# 3. 影响分析
/devbooks-impact-analysis

# 4. 实现（保持测试不变）
/devbooks-coder

# 5. 评审
/devbooks-reviewer

# 6. 归档
/devbooks-archiver
```

### 场景 4：存量项目接入

```bash
# 1. 初始化
/devbooks-brownfield-bootstrap

# 2. 开始第一个变更
/devbooks-proposal-author
```

### 场景 5：评估工作流收敛性

当你跑了几个变更包闭环后，想评估是否真正推进：

```bash
# 评估变更包是否有效推进
/devbooks-convergence-audit
```

这个 skill 会检测：
- 是否陷入"边修边破"循环
- 是否在"修复一个 Bug 引入两个 Bug"
- 变更包之间是否有真正的进展

---

## 质量保证

### 质量闸门

DevBooks 提供多重质量闸门：

1. **Green 证据检查**：测试必须通过
2. **任务完成率**：tasks.md 中的任务必须 100% 完成
3. **角色边界检查**：Coder 不能修改 tests/
4. **架构约束检查**：Fitness Rules 验证
5. **文档一致性检查**：代码与文档同步

### Completion Contract 与上游宣称（G6）

当你需要避免“本包自定义验收全绿，但宣称完成的上游义务其实没交付”的假完成时，使用 Completion Contract 的 `upstream_claims`：

- 在真理源（truth）提供可机读的 `requirements.index.yaml`（`schema_version: 1.0.0`）
- 若项目没有上游 SSOT，先落盘最小项目级 SSOT 包：`<truth-root>/ssot/SSOT.md` + `<truth-root>/ssot/requirements.index.yaml`（可用 `skills/devbooks-delivery-workflow/scripts/ssot-scaffold.sh` 一键生成骨架）
- 若项目存在上游 SSOT（例如 `SSOT docs/`），在 `.devbooks/config.yaml` 配置：
  - `truth_mapping: { ssot_root: "SSOT docs/" }`（只索引引用，不复制长文档原文）
- 当你修改/同步 SSOT 后，用 `devbooks-ssot-maintainer` 维护索引与派生账本：
  - 写 delta：`<change-root>/<change-id>/inputs/ssot.delta.yaml`
  - 执行：`skills/devbooks-ssot-maintainer/scripts/ssot-index-sync.sh --delta <path> --apply --refresh-ledger`
- 在 `completion.contract.yaml` 中声明你覆盖的是 `complete` 还是 `subset`
- G6 归档会输出 `evidence/gates/G6-archive-decider.json`，并对每条宣称给出 `upstream_claims_evaluation[]`（must 覆盖率、未覆盖列表、deferred、next_action 可解析性）

示例（block list，避免 YAML 子集误伤）：

```yaml
upstream_claims:
  - set_ref: truth://ssot/requirements.index.yaml
    claim: subset
    covered:
      - R-001
    deferred:
      - R-002
    next_action_ref: change://20260101-0000-next-change/proposal.md
```

### 适应度函数

```bash
# 定义架构约束
# dev-playbooks/specs/architecture/fitness-rules.md

# 验证约束
/devbooks-convergence-audit
```

### 熵度量

```bash
# 监控系统熵度
/devbooks-entropy-monitor
```

度量维度：
- 结构熵：模块耦合度
- 变更熵：变更频率
- 测试熵：测试覆盖率
- 依赖熵：依赖复杂度

---

## 故障排查

### 问题 1：测试不通过

**症状**：Coder 声称完成，但测试失败

**解决**：
1. 检查 Test Owner 是否先跑出 Red 基线
2. 检查 Coder 是否修改了 tests/
3. 检查任务完成率是否 100%

### 问题 2：角色隔离失败

**症状**：同一对话中既写测试又写代码

**解决**：
1. 启用 `role_isolation: true` 配置
2. 使用独立对话分别调用 test-owner 和 coder

### 问题 3：文档与代码不一致

**症状**：文档描述与实际行为不符

**解决**：
```bash
# 运行文档一致性检查
/devbooks-docs-consistency

# 或在归档时自动检查
/devbooks-archiver
```

### 问题 4：变更包混乱

**症状**：多个变更包交叉修改

**解决**：
1. 使用 `/devbooks:delivery` 重新路由并输出当前状态/下一步
2. 一次只处理一个变更包
3. 完成后立即归档

### 问题 5：存量项目无从下手

**症状**：不知道如何在现有代码库中使用 DevBooks

**解决**：
```bash
# 运行存量初始化
/devbooks-brownfield-bootstrap
```

---

## 进阶技巧

### 1. 自定义配置

编辑 `.devbooks/config.yaml`：

```yaml
# 角色隔离
constraints:
  role_isolation: true
  coder_no_tests: true

# 适应度函数
fitness:
  mode: error  # error | warn | off
  rules_file: specs/architecture/fitness-rules.md

# 提案对辩
proposal:
  enable_debate: true
  require_impact_analysis: true
```

### 2. 自定义文档规则

编辑 `.devbooks/docs-rules.yaml`：

```yaml
global_cleanup:
  - name: "统一术语"
    pattern: "变更集"
    replace: "变更包"
    scope: "all_docs"
```

### 3. 完整闭环自动化

```bash
# 运行完整工作流
/devbooks:delivery
```

---

## 总结

DevBooks 的核心价值：

1. **角色隔离**：Test Owner 与 Coder 独立工作
2. **规格驱动**：所有代码追溯到 AC-xxx
3. **证据优先**：完成由测试/构建验证
4. **质量闸门**：多重检查确保质量
5. **完整闭环**：从提案到归档的全流程

**记住**：DevBooks 不是工具，而是一套工作流程。遵循约束，质量自然提升。

---

**相关文档**：
- [Skill 详解](./Skill详解.md)
