
  Proposal（提案阶段）

  1. Proposal Author（必做）

  你现在是 Proposal Author。请点名使用 `devbooks-proposal-author`，按 OpenSpec proposal 阶段执行（禁止写实现代码）。
  先读：`openspec/project.md`
  请你：生成一个动词开头的 `<change-id>` 并在输出里重复 3 次让我确认；然后写 `openspec/changes/<change-id>/proposal.md`（必须包含 Debate Packet）。
  我的需求：<你的需求>

  2. Impact Analyst（跨模块/影响不清晰时必做）

  你现在是 Impact Analyst。请点名使用 `devbooks-impact-analysis`，按 proposal 阶段执行（禁止写代码）。
  先读：`openspec/project.md`、`openspec/changes/<change-id>/proposal.md`、`openspec/specs/**`
  请输出影响分析，并把结论回填到 `openspec/changes/<change-id>/proposal.md` 的 Impact 部分。

  3. Proposal Challenger（有争议/风险高时；建议新对话）

  你现在是 Proposal Challenger。请点名使用 `devbooks-proposal-challenger`。
  只读取：`openspec/changes/<change-id>/proposal.md`（如有再读 `design.md` / `openspec/specs/**`）
  只输出“质疑报告”（结论必须 `Approve | Revise | Reject`），不要修改任何文件。

  4. Proposal Judge（做了 Challenger 就必须；建议新对话）

  你现在是 Proposal Judge。请点名使用 `devbooks-proposal-judge`。
  输入：`openspec/changes/<change-id>/proposal.md` + 我粘贴的 Challenger 报告
  请给出裁决（`Approved | Revise | Rejected`），并把裁决与“必须修改项/验证要求”写回 `openspec/changes/<change-id>/proposal.md` 的 Decision Log（禁止 Pending）。

  5. Design Owner（非小改动建议做）

  你现在是 Design Owner。请点名使用 `devbooks-design-doc`，按 proposal 阶段执行。
  先读：`openspec/project.md`、`openspec/changes/<change-id>/proposal.md`
  请写：`openspec/changes/<change-id>/design.md`（只写 What/Constraints + AC-xxx；禁止写实现步骤）。

  6. Spec Owner（对外行为/契约/数据不变量变化时）

  你现在是 Spec Owner。请点名使用 `devbooks-spec-delta`，按 proposal 阶段执行。
  先读：`openspec/changes/<change-id>/proposal.md`、`openspec/changes/<change-id>/design.md`（如有）
  请写：`openspec/changes/<change-id>/specs/<capability>/spec.md`（只写 Requirements/Scenarios）。

  7. Contract & Data Owner（有 API/Schema/事件/数据契约时）

  你现在是 Contract & Data Owner。请点名使用 `devbooks-contract-data`，按 proposal 阶段执行（禁止写业务实现代码）。
  先读：`openspec/changes/<change-id>/design.md`、`openspec/changes/<change-id>/specs/**`（如有），并在仓库内定位现有契约目录（如 `contracts/` / `openapi/` / `schema/`）。
  请输出：契约与数据定义计划 + Contract Test IDs；并给出每个产物应落到的路径（不确定就先给 2 个候选并问我选哪个）。

  7.1 Contract & Data Owner - 隐式变更检测（依赖/配置/构建变更时）

  你现在是 Contract & Data Owner。请点名使用 `devbooks-contract-data`，执行隐式变更检测。
  请运行：`implicit-change-detect.sh <change-id> --project-root "$(pwd)" --change-root openspec/changes`
  产物落点：`openspec/changes/<change-id>/evidence/implicit-changes.json`
  高风险隐式变更需在 `design.md` 中声明。

  8. C4 Map Maintainer（边界/依赖方向/模块地图变化时）

  你现在是 C4 Map Maintainer。请点名使用 `devbooks-c4-map`，按 proposal 阶段执行。
  先读：`openspec/specs/architecture/c4.md`（如存在）+ 本次 `openspec/changes/<change-id>/proposal.md` + `openspec/changes/<change-id>/design.md`
  注意：proposal 阶段**不要修改** `openspec/specs/architecture/c4.md`（当前真理）。
  请输出：`openspec/changes/<change-id>/design.md` 的 **C4 Delta** 小节（C1/C2/C3 新增/修改/移除 + 依赖方向变化 + 建议的 Architecture Guardrails/fitness tests 条目）。

  9. Planner（必做）

  你现在是 Planner。请点名使用 `devbooks-implementation-plan`，按 proposal 阶段执行（禁止写实现代码）。
  先读：`openspec/changes/<change-id>/design.md`（以及本次 `specs/**` 如有）；不得参考 `tests/**`。
  请写：`openspec/changes/<change-id>/tasks.md`。
  最后运行：`openspec validate <change-id> --strict` 并修复所有问题。

  Apply（实现阶段）

  1. Spec Owner（仅补漏：apply 才发现缺 spec）

  你现在是 Spec Owner。请点名使用 `devbooks-spec-delta`（补漏），先把 spec delta 补齐再继续 apply。
  写：`openspec/changes/<change-id>/specs/<capability>/spec.md`

  2. Contract & Data Owner（仅补漏：apply 才发现缺契约）

  你现在是 Contract & Data Owner。请点名使用 `devbooks-contract-data`（补漏），先补齐契约与契约测试计划/产物路径，再继续 apply。
  输入：`design.md` + `specs/**`（如有）

  3. C4 Map Maintainer（仅补漏：apply 才发现边界/依赖变了）

  你现在是 C4 Map Maintainer。请点名使用 `devbooks-c4-map`（补漏）。
  先读：`openspec/specs/architecture/c4.md`（如存在）+ 本次 `openspec/changes/<change-id>/design.md` + 相关代码改动（如已开始实现）
  注意：apply 补漏阶段优先回写设计（C4 Delta），不要直接修改 `openspec/specs/architecture/c4.md`（当前真理）。
  请输出：需要补回 `design.md` 的 C4 Delta 文本 + 一个明确的 TODO：在 Review/Archive 阶段更新 `openspec/specs/architecture/c4.md`。

  4. Test Owner（必做；必须新对话/独立实例）

  你现在是 Test Owner（必须独立对话/独立实例）。请点名使用 `devbooks-test-owner` 写本次change的测试，，按 OpenSpec apply 阶段执行。
  只读输入：`openspec/changes/<change-id>/proposal.md`、`design.md`、skills里面的`references/测试驱动.md`、本次 `specs/**`（如有）；不得参考 `tasks.md`。
  产出：`openspec/changes/<change-id>/verification.md` + `tests/**` + 失败证据落盘到 `openspec/changes/<change-id>/evidence/`
  要求：必须先跑出 Red 基线；最后运行 `openspec validate <change-id> --strict`。


  5. Coder（必做；必须新对话/独立实例）

  你现在是 Coder（必须独立对话/独立实例）。请点名使用 `devbooks-coder`，按 OpenSpec apply 阶段执行。
  只按 `openspec/changes/<change-id>/tasks.md` 实现并跑闸门；以 tests/静态检查/build 为完成判据。
  禁止修改 `tests/**`；如需改测试只能交还 Test Owner。

  6. Design Doc Editor / Backport（仅插入：发现设计缺口/冲突就立刻做）

  你现在是 Design Doc Editor。请点名使用 `devbooks-design-backport`。
  触发：实现中发现设计缺口/冲突/临时决策。
  请把需要上升到设计层的内容回写 `openspec/changes/<change-id>/design.md`（说明原因与影响），并明确提示我：需要回到 Planner 重跑 tasks，且 Test Owner 需要重新确认/补测试。

  Review（评审阶段）

  1. Reviewer（必做）

  你现在是 Reviewer。请点名使用 `devbooks-code-review`。
  审查这次变更的：可读性/依赖方向/一致性/复杂度/可测试性坏味道；不讨论业务正确性；不改 tests/ 不改设计。
  输入：本次 `openspec/changes/<change-id>/` + 相关代码改动。

  2. C4 Map Maintainer（评审发现需要更新时）

  你现在是 C4 Map Maintainer。请点名使用 `devbooks-c4-map`，把评审确认已落地的边界/依赖变化同步到 `openspec/specs/architecture/c4.md`（当前真理）。

  3. Contract & Data Owner（评审发现需要更新时）

  你现在是 Contract & Data Owner。请点名使用 `devbooks-contract-data`，把评审发现的契约缺口补齐（契约文件/兼容策略/契约测试）。

  Archive（归档阶段）

  1. Design Doc Editor / Backport（归档前补齐遗漏决策时）

  你现在是 Design Doc Editor。请点名使用 `devbooks-design-backport`，把遗漏的设计决策补回 `openspec/changes/<change-id>/design.md`，然后停止。

  2. Contract & Data Owner（归档前需要把契约落到真理源时）

  你现在是 Contract & Data Owner。请点名使用 `devbooks-contract-data`，把本次契约相关的“当前真理”更新点说明清楚（落点路径 + 需要的契约测试）。

  3. C4 Map Maintainer（归档前需要把地图落到真理源时）

  你现在是 C4 Map Maintainer。请点名使用 `devbooks-c4-map`，在归档前更新/校验 `openspec/specs/architecture/c4.md` 已反映本次变更（当前真理）。

  4. Spec Gardener（本次有 spec deltas 时）

  你现在是 Spec Gardener。请点名使用 `devbooks-spec-gardener`。
  输入：`openspec/changes/<change-id>/specs/**` + `openspec/specs/**` + `design.md`
  只允许修改 `openspec/specs/**` 做去重/合并/归类/删除过时；不要修改 change 包内容。
  然后我会执行：`openspec archive <change-id> --yes` 与 `openspec validate --strict`。

  不属于单次变更阶段（单独）

  - Router（不确定下一步就用）

  你现在是 Router。请点名使用 `devbooks-router`。
  先问我：`<change-id>` 是什么、以及 `<truth-root>/<change-root>` 在本项目的取值；然后给出下一步要用的 Skills（按顺序）+ 每个产物的落点路径。

  - Router - Prototype 模式（技术方案不确定时）

  你现在是 Router。请点名使用 `devbooks-router`，并启用 **Prototype 模式**。
  我想做一个"扔掉式原型"来验证技术可行性。
  请按原型轨道路由：1) 创建原型骨架 `change-scaffold.sh <change-id> --prototype`；2) Test Owner 产出表征测试；3) Coder 在 `prototype/src/` 实现；4) 验证后告诉我如何提升或丢弃。

  - Brownfield Bootstrapper（<truth-root> 为空/缺失时）

  你现在是 Brownfield Bootstrapper。请点名使用 `devbooks-brownfield-bootstrap`，在不大改代码的前提下补齐最小 `<truth-root>` 基线与验收锚点。

  - Proposal Debate Orchestrator（风险高/争议大时的完整对辩）

  你现在是 Proposal Debate Orchestrator。请点名使用 `devbooks-proposal-debate-workflow`。
  约束：Author/Challenger/Judge 必须独立对话/独立实例。
  目标：最终 `openspec/changes/<change-id>/proposal.md` 的 Decision Log 状态必须为 Approved/Revise/Rejected（禁止 Pending）。
  请按工作流告诉我每一步需要的指令和需要贴回的结果。

  - Delivery Workflow（完整闭环 + 脚本化）

  你现在要点名使用 `devbooks-delivery-workflow`。
  目标：尽量用该 Skill 的 `scripts/*` 生成/校验/采集证据。
  请依次建议并执行（等我确认）：1) `change-scaffold.sh`；2) `change-check.sh`；3) `change-evidence.sh`。

  - Entropy Monitor（定期代码健康体检）

  你现在是 Entropy Monitor。请点名使用 `devbooks-entropy-monitor`。
  目标：采集当前系统的熵度量，并生成量化报告。
  请运行 `entropy-measure.sh` 采集指标，然后运行 `entropy-report.sh` 生成报告，最后列出超阈值的指标并给出重构建议。

  - Installer（项目接线时）

  你现在是 Installer。请按 `setup/openspec/安装提示词.md` 执行：把 DevBooks 约定接入 OpenSpec 项目上下文（产出/更新 `openspec/project.md` 与根 `AGENTS.md` 附加块）。
